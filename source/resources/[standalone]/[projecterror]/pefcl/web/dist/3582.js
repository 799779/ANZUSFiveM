"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[3582],{3582:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Provider: function() { return /* binding */ Provider; },\n  SECRET_INTERNAL_getScopeContext: function() { return /* binding */ getScopeContext; },\n  SECRET_INTERNAL_registerPromiseAbort: function() { return /* binding */ registerPromiseAbort; },\n  atom: function() { return /* binding */ esm_atom; },\n  unstable_createStore: function() { return /* binding */ createStoreForExport; },\n  useAtom: function() { return /* binding */ useAtom; },\n  useAtomValue: function() { return /* binding */ useAtomValue; },\n  useSetAtom: function() { return /* binding */ useSetAtom; }\n});\n\n// EXTERNAL MODULE: consume shared module (default) react@^17.0.2 (singleton) (fallback: ./node_modules/react/index.js)\nvar index_js_ = __webpack_require__(2950);\n;// CONCATENATED MODULE: ./node_modules/jotai/esm/vanilla.mjs\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === "function") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, arg) => set(\n      config,\n      typeof arg === "function" ? arg(get(config)) : arg\n    );\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nconst hasInitialValue = (atom) => "init" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelPromiseMap = /* @__PURE__ */ new WeakMap();\nconst registerCancelPromise = (promise, cancel) => {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(() => {\n  }).finally(() => cancelPromiseMap.delete(promise));\n};\nconst cancelPromise = (promise, next) => {\n  const cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nconst resolvePromise = (promise, value) => {\n  promise.status = "fulfilled";\n  promise.value = value;\n};\nconst rejectPromise = (promise, e) => {\n  promise.status = "rejected";\n  promise.reason = e;\n};\nconst isEqualAtomValue = (a, b) => "v" in a && "v" in b && Object.is(a.v, b.v);\nconst isEqualAtomError = (a, b) => "e" in a && "e" in b && Object.is(a.e, b.e);\nconst hasPromiseAtomValue = (a) => "v" in a && a.v instanceof Promise;\nconst returnAtomValue = (atomState) => {\n  if ("e" in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if (true) {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => atomStateMap.get(atom);\n  const setAtomState = (atom, atomState) => {\n    if (true) {\n      Object.freeze(atomState);\n    }\n    const prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      const next = "v" in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, next);\n    }\n  };\n  const updateDependencies = (atom, nextAtomState, depSet) => {\n    const dependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    depSet.forEach((a) => {\n      const aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if (true) {\n        console.warn("[Bug] atom state not found");\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  const setAtomValue = (atom, value, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomError = (atom, error, depSet) => {\n    const prevAtomState = getAtomState(atom);\n    const nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || /* @__PURE__ */ new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  const readAtomState = (atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(\n        ([a, s]) => a === atom || getAtomState(a) === s\n      )) {\n        return atomState;\n      }\n    }\n    const depSet = /* @__PURE__ */ new Set();\n    let isSync = true;\n    const getter = (a) => {\n      depSet.add(a);\n      if (a === atom) {\n        const aState2 = getAtomState(a);\n        if (aState2) {\n          return returnAtomValue(aState2);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error("no atom init");\n      }\n      const aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ( true && !isActuallyWritableAtom(atom)) {\n          console.warn("setSelf function cannot be used with read-only atom");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ( true && isSync) {\n              console.warn("setSelf function cannot be called in sync");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        let continuePromise;\n        const promise = new Promise((resolve, reject) => {\n          let settled = false;\n          value.then(\n            (v) => {\n              if (!settled) {\n                resolvePromise(promise, v);\n                resolve(v);\n              }\n            },\n            (e) => {\n              if (!settled) {\n                rejectPromise(promise, e);\n                reject(e);\n              }\n            }\n          ).finally(() => {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = (next) => {\n            if (!settled) {\n              settled = true;\n              next.then(\n                (v) => resolvePromise(promise, v),\n                (e) => rejectPromise(promise, e)\n              );\n              resolve(next);\n            }\n          };\n        });\n        promise.status = "pending";\n        registerCancelPromise(promise, (next) => {\n          if (next) {\n            continuePromise(next);\n          }\n          controller == null ? void 0 : controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const addAtom = (atom) => {\n    let mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (atom) => {\n    const mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  const recomputeDependents = (atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        const prevAtomState = getAtomState(dependent);\n        const nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error("atom not writable");\n        }\n        const prevAtomState = getAtomState(a);\n        const nextAtomState = setAtomValue(a, args2[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState(a, ...args2);\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    isSync = false;\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const result = writeAtomState(atom, ...args);\n    flushPending();\n    return result;\n  };\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (true) {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const onUnmount = atom.onMount((...args) => writeAtom(atom, ...args));\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (true) {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (true) {\n      console.warn("[Bug] could not find atom state to unmount", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevDependencies) => {\n    const depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach((_, a) => {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = () => {\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          const mounted = mountedMap.get(atom);\n          if (mounted && !// TODO This seems pretty hacky. Hope to fix it.\n          // Maybe we could `mountDependencies` in `setAtomState`?\n          (prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach((listener) => listener());\n          }\n        } else if (true) {\n          console.warn("[Bug] no atom state to flush");\n        }\n      });\n    }\n    if (true) {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const subscribeAtom = (atom, listener) => {\n    const mounted = addAtom(atom);\n    flushPending();\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if (true) {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      // store dev methods (these are tentative and subject to change)\n      dev_subscribe_state: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: () => mountedAtoms.values(),\n      dev_get_atom_state: (a) => atomStateMap.get(a),\n      dev_get_mounted: (a) => mountedMap.get(a),\n      dev_restore_atoms: (values) => {\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/jotai/esm/index.mjs\n\n\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a;\n  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];\n  if (cancelPromise) {\n    cancelPromise();\n    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();\n  }\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (basePromise, promise) => {\n  const suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    suspensePromiseExtra.c = () => {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nconst copySuspensePromise = (suspensePromise) => createSuspensePromise(\n  suspensePromise[SUSPENSE_PROMISE].b,\n  suspensePromise[SUSPENSE_PROMISE].o\n);\nconst promiseAbortMap = /* @__PURE__ */ new WeakMap();\nconst registerPromiseAbort = (basePromise, abort) => {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nconst esm_hasInitialValue = (atom) => "init" in atom;\nconst READ_ATOM = "r";\nconst WRITE_ATOM = "w";\nconst COMMIT_ATOM = "c";\nconst SUBSCRIBE_ATOM = "s";\nconst RESTORE_ATOMS = "h";\nconst DEV_SUBSCRIBE_STATE = "n";\nconst DEV_GET_MOUNTED_ATOMS = "l";\nconst DEV_GET_ATOM_STATE = "a";\nconst DEV_GET_MOUNTED = "m";\nconst esm_createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if (true) {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        // not invalidated\n        d: /* @__PURE__ */ new Map()\n      };\n      if (true) {\n        Object.freeze(atomState);\n        if (!esm_hasInitialValue(atom)) {\n          console.warn(\n            "Found initial value for derived atom which can cause unexpected behavior",\n            atom\n          );\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState && "p" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          atomState = void 0;\n        }\n        if (atomState) {\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if (true) {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if ("p" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = !(atomState == null ? void 0 : atomState.y);\n    if (!atomState || !("v" in atomState) || // new value, or\n    !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if ("p" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      // set read error\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && "p" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return { ...atomState, y: true };\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      // not invalidated\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(\n        promiseOrValue,\n        promiseOrValue.then((value) => {\n          setAtomValue(version, atom, value, dependencies, suspensePromise);\n        }).catch((e) => {\n          if (e instanceof Promise) {\n            if (isSuspensePromise(e)) {\n              return e.then(() => {\n                readAtomState(version, atom, true);\n              });\n            }\n            return e;\n          }\n          setAtomReadError(version, atom, e, dependencies, suspensePromise);\n        })\n      );\n      return setAtomSuspensePromise(\n        version,\n        atom,\n        suspensePromise,\n        dependencies\n      );\n    }\n    return setAtomValue(\n      version,\n      atom,\n      promiseOrValue,\n      dependencies\n    );\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = {\n        ...atomState,\n        // copy everything\n        y: false\n        // invalidated\n      };\n      setAtomState(version, atom, nextAtomState);\n    } else if (true) {\n      console.warn("[Bug] could not invalidate non existing atom", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.y && // not invalidated\n        "p" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && !("p" in aState) && // has no suspense promise\n          aState.r === r;\n        })) {\n          if (!atomState.y) {\n            return { ...atomState, y: true };\n          }\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if ("e" in aState) {\n            throw aState.e;\n          }\n          if ("p" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (esm_hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error("no atom init");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(\n          version,\n          atom,\n          suspensePromise,\n          dependencies\n        );\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (version, addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (version, deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if ("e" in aState) {\n        throw aState.e;\n      }\n      if ("p" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => {\n            const s = getAtomState(version, a);\n            if (s && "p" in s && s.p === aState.p) {\n              return new Promise((resolve) => setTimeout(resolve)).then(\n                () => writeGetter(a, options)\n              );\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if (true) {\n          console.info(\n            "Reading pending atom state in write operation. We throw a promise for now.",\n            a\n          );\n        }\n        throw aState.p;\n      }\n      if ("v" in aState) {\n        return aState.v;\n      }\n      if (true) {\n        console.warn(\n          "[Bug] no value found while reading atom in write operation. This is probably a bug.",\n          a\n        );\n      }\n      throw new Error("no value found");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!esm_hasInitialValue(a)) {\n          throw new Error("atom not writable");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (version, atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (true) {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update, version);\n      const onUnmount = atom.onMount(setAtom);\n      version = void 0;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (version, atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (true) {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if ("p" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if (true) {\n      console.warn("[Bug] could not find atom state to unmount", atom);\n    }\n  };\n  const mountDependencies = (version, atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(void 0, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && // invalidated\n        (atomState == null ? void 0 : atomState.y)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if (true) {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback, version) => {\n    const mounted = addAtom(version, atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (esm_hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if (true) {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = esm_createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if ("e" in atomState) {\n      throw atomState.e;\n    }\n    if ("p" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if ("e" in atomState) {\n      reject(atomState.e);\n    } else if ("p" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : esm_createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, (0,index_js_.createContext)(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = (0,index_js_.useState)({});\n  (0,index_js_.useEffect)(() => {\n    const scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  const scopeContainerRef = (0,index_js_.useRef)();\n  if (!scopeContainerRef.current) {\n    const scopeContainer = createScopeContainer(\n      initialValues,\n      unstable_createStore\n    );\n    if (unstable_enableVersionedWrite) {\n      let retrying = 0;\n      scopeContainer.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = retrying ? parentVersion : { p: parentVersion };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = (fn) => {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return (0,index_js_.createElement)(\n    ScopeContainerContext.Provider,\n    {\n      value: scopeContainerRef.current\n    },\n    children\n  );\n};\n\nfunction esm_atom(read, write) {\n  return atom(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const scopeContainer = (0,index_js_.useContext)(ScopeContext);\n  const { s: store, v: versionFromProvider } = scopeContainer;\n  const getAtomValue = (version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if ( true && !atomState.y) {\n      throw new Error("should not be invalidated");\n    }\n    if ("e" in atomState) {\n      throw atomState.e;\n    }\n    if ("p" in atomState) {\n      throw atomState.p;\n    }\n    if ("v" in atomState) {\n      return atomState.v;\n    }\n    throw new Error("no atom value");\n  };\n  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = (0,index_js_.useReducer)(\n    (prev, nextVersion) => {\n      const nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    },\n    versionFromProvider,\n    (initialVersion) => {\n      const initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }\n  );\n  let value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  (0,index_js_.useEffect)(() => {\n    const { v: versionFromProvider2 } = scopeContainer;\n    if (versionFromProvider2) {\n      store[COMMIT_ATOM](atom, versionFromProvider2);\n    }\n    const unsubscribe = store[SUBSCRIBE_ATOM](\n      atom,\n      rerenderIfChanged,\n      versionFromProvider2\n    );\n    rerenderIfChanged(versionFromProvider2);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  (0,index_js_.useEffect)(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  (0,index_js_.useDebugValue)(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = (0,index_js_.useContext)(ScopeContext);\n  const setAtom = (0,index_js_.useCallback)(\n    (update) => {\n      if ( true && !("write" in atom)) {\n        throw new Error("not writable atom");\n      }\n      const write = (version) => store[WRITE_ATOM](atom, update, version);\n      return versionedWrite ? versionedWrite(write) : write();\n    },\n    [store, versionedWrite, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if ("scope" in atom) {\n    console.warn(\n      "atom.scope is deprecated. Please do useAtom(atom, scope) instead."\n    );\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, scope)\n  ];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU4Mi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUEwRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUEwRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUyxJQUEwRDtBQUMzRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxZQUFZLEtBQTBEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQTBEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQTBEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBMEQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNLFNBQVMsSUFBMEQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsSUFBMEQ7QUFDN0U7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVEsSUFBMEQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEM7OztBQ25jd0Y7QUFDdkY7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sbUJBQWU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxlQUFXO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBMEQ7QUFDcEU7QUFDQSxhQUFhLG1CQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUEwRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsSUFBMEQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFlBQVksSUFBMEQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLElBQTBEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQTBEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQTBEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxTQUFTLElBQTBEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVEsSUFBMEQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1HQUFtRyxlQUFXO0FBQzlHLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyQkFBYTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDQUFnQyxzQkFBUSxHQUFHO0FBQzNDLEVBQUUsdUJBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNEJBQTRCLG9CQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJCQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxRQUFJO0FBQ2IsU0FBUyxJQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qix3QkFBVTtBQUNuQyxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0EsUUFBUSxLQUEwRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSx3QkFBVTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsdUJBQVM7QUFDWCxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLHVCQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0gsRUFBRSwyQkFBYTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsOEJBQThCLEVBQUUsd0JBQVU7QUFDcEQsa0JBQWtCLHlCQUFXO0FBQzdCO0FBQ0EsVUFBVSxLQUEwRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzPzhjYzYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2pvdGFpL2VzbS9pbmRleC5tanM/MDEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQga2V5Q291bnQgPSAwO1xuZnVuY3Rpb24gYXRvbShyZWFkLCB3cml0ZSkge1xuICBjb25zdCBrZXkgPSBgYXRvbSR7KytrZXlDb3VudH1gO1xuICBjb25zdCBjb25maWcgPSB7XG4gICAgdG9TdHJpbmc6ICgpID0+IGtleVxuICB9O1xuICBpZiAodHlwZW9mIHJlYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbmZpZy5yZWFkID0gcmVhZDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcuaW5pdCA9IHJlYWQ7XG4gICAgY29uZmlnLnJlYWQgPSAoZ2V0KSA9PiBnZXQoY29uZmlnKTtcbiAgICBjb25maWcud3JpdGUgPSAoZ2V0LCBzZXQsIGFyZykgPT4gc2V0KFxuICAgICAgY29uZmlnLFxuICAgICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldChjb25maWcpKSA6IGFyZ1xuICAgICk7XG4gIH1cbiAgaWYgKHdyaXRlKSB7XG4gICAgY29uZmlnLndyaXRlID0gd3JpdGU7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3QgaGFzSW5pdGlhbFZhbHVlID0gKGF0b20pID0+IFwiaW5pdFwiIGluIGF0b207XG5jb25zdCBpc0FjdHVhbGx5V3JpdGFibGVBdG9tID0gKGF0b20pID0+ICEhYXRvbS53cml0ZTtcbmNvbnN0IGNhbmNlbFByb21pc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyQ2FuY2VsUHJvbWlzZSA9IChwcm9taXNlLCBjYW5jZWwpID0+IHtcbiAgY2FuY2VsUHJvbWlzZU1hcC5zZXQocHJvbWlzZSwgY2FuY2VsKTtcbiAgcHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gIH0pLmZpbmFsbHkoKCkgPT4gY2FuY2VsUHJvbWlzZU1hcC5kZWxldGUocHJvbWlzZSkpO1xufTtcbmNvbnN0IGNhbmNlbFByb21pc2UgPSAocHJvbWlzZSwgbmV4dCkgPT4ge1xuICBjb25zdCBjYW5jZWwgPSBjYW5jZWxQcm9taXNlTWFwLmdldChwcm9taXNlKTtcbiAgaWYgKGNhbmNlbCkge1xuICAgIGNhbmNlbFByb21pc2VNYXAuZGVsZXRlKHByb21pc2UpO1xuICAgIGNhbmNlbChuZXh0KTtcbiAgfVxufTtcbmNvbnN0IHJlc29sdmVQcm9taXNlID0gKHByb21pc2UsIHZhbHVlKSA9PiB7XG4gIHByb21pc2Uuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgcHJvbWlzZS52YWx1ZSA9IHZhbHVlO1xufTtcbmNvbnN0IHJlamVjdFByb21pc2UgPSAocHJvbWlzZSwgZSkgPT4ge1xuICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgcHJvbWlzZS5yZWFzb24gPSBlO1xufTtcbmNvbnN0IGlzRXF1YWxBdG9tVmFsdWUgPSAoYSwgYikgPT4gXCJ2XCIgaW4gYSAmJiBcInZcIiBpbiBiICYmIE9iamVjdC5pcyhhLnYsIGIudik7XG5jb25zdCBpc0VxdWFsQXRvbUVycm9yID0gKGEsIGIpID0+IFwiZVwiIGluIGEgJiYgXCJlXCIgaW4gYiAmJiBPYmplY3QuaXMoYS5lLCBiLmUpO1xuY29uc3QgaGFzUHJvbWlzZUF0b21WYWx1ZSA9IChhKSA9PiBcInZcIiBpbiBhICYmIGEudiBpbnN0YW5jZW9mIFByb21pc2U7XG5jb25zdCByZXR1cm5BdG9tVmFsdWUgPSAoYXRvbVN0YXRlKSA9PiB7XG4gIGlmIChcImVcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICB0aHJvdyBhdG9tU3RhdGUuZTtcbiAgfVxuICByZXR1cm4gYXRvbVN0YXRlLnY7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGF0b21TdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBtb3VudGVkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IHBlbmRpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgc3RhdGVMaXN0ZW5lcnM7XG4gIGxldCBtb3VudGVkQXRvbXM7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBzdGF0ZUxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbW91bnRlZEF0b21zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxuICBjb25zdCBnZXRBdG9tU3RhdGUgPSAoYXRvbSkgPT4gYXRvbVN0YXRlTWFwLmdldChhdG9tKTtcbiAgY29uc3Qgc2V0QXRvbVN0YXRlID0gKGF0b20sIGF0b21TdGF0ZSkgPT4ge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoYXRvbVN0YXRlKTtcbiAgICB9XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gICAgYXRvbVN0YXRlTWFwLnNldChhdG9tLCBhdG9tU3RhdGUpO1xuICAgIGlmICghcGVuZGluZ01hcC5oYXMoYXRvbSkpIHtcbiAgICAgIHBlbmRpbmdNYXAuc2V0KGF0b20sIHByZXZBdG9tU3RhdGUpO1xuICAgIH1cbiAgICBpZiAocHJldkF0b21TdGF0ZSAmJiBoYXNQcm9taXNlQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUpKSB7XG4gICAgICBjb25zdCBuZXh0ID0gXCJ2XCIgaW4gYXRvbVN0YXRlID8gYXRvbVN0YXRlLnYgaW5zdGFuY2VvZiBQcm9taXNlID8gYXRvbVN0YXRlLnYgOiBQcm9taXNlLnJlc29sdmUoYXRvbVN0YXRlLnYpIDogUHJvbWlzZS5yZWplY3QoYXRvbVN0YXRlLmUpO1xuICAgICAgY2FuY2VsUHJvbWlzZShwcmV2QXRvbVN0YXRlLnYsIG5leHQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdXBkYXRlRGVwZW5kZW5jaWVzID0gKGF0b20sIG5leHRBdG9tU3RhdGUsIGRlcFNldCkgPT4ge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBkZXBTZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgYVN0YXRlID0gYSA9PT0gYXRvbSA/IG5leHRBdG9tU3RhdGUgOiBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICBpZiAoYVN0YXRlKSB7XG4gICAgICAgIGRlcGVuZGVuY2llcy5zZXQoYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKG5leHRBdG9tU3RhdGUuZC5nZXQoYSkgIT09IGFTdGF0ZSkge1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBhdG9tIHN0YXRlIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZCB8fCBuZXh0QXRvbVN0YXRlLmQuc2l6ZSAhPT0gZGVwZW5kZW5jaWVzLnNpemUpIHtcbiAgICAgIG5leHRBdG9tU3RhdGUuZCA9IGRlcGVuZGVuY2llcztcbiAgICB9XG4gIH07XG4gIGNvbnN0IHNldEF0b21WYWx1ZSA9IChhdG9tLCB2YWx1ZSwgZGVwU2V0KSA9PiB7XG4gICAgY29uc3QgcHJldkF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZShhdG9tKTtcbiAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0ge1xuICAgICAgZDogKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIHY6IHZhbHVlXG4gICAgfTtcbiAgICBpZiAoZGVwU2V0KSB7XG4gICAgICB1cGRhdGVEZXBlbmRlbmNpZXMoYXRvbSwgbmV4dEF0b21TdGF0ZSwgZGVwU2V0KTtcbiAgICB9XG4gICAgaWYgKHByZXZBdG9tU3RhdGUgJiYgaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSAmJiBwcmV2QXRvbVN0YXRlLmQgPT09IG5leHRBdG9tU3RhdGUuZCkge1xuICAgICAgcmV0dXJuIHByZXZBdG9tU3RhdGU7XG4gICAgfVxuICAgIHNldEF0b21TdGF0ZShhdG9tLCBuZXh0QXRvbVN0YXRlKTtcbiAgICByZXR1cm4gbmV4dEF0b21TdGF0ZTtcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbUVycm9yID0gKGF0b20sIGVycm9yLCBkZXBTZXQpID0+IHtcbiAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGF0b20pO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBkOiAocHJldkF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcHJldkF0b21TdGF0ZS5kKSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgZTogZXJyb3JcbiAgICB9O1xuICAgIGlmIChkZXBTZXQpIHtcbiAgICAgIHVwZGF0ZURlcGVuZGVuY2llcyhhdG9tLCBuZXh0QXRvbVN0YXRlLCBkZXBTZXQpO1xuICAgIH1cbiAgICBpZiAocHJldkF0b21TdGF0ZSAmJiBpc0VxdWFsQXRvbUVycm9yKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpICYmIHByZXZBdG9tU3RhdGUuZCA9PT0gbmV4dEF0b21TdGF0ZS5kKSB7XG4gICAgICByZXR1cm4gcHJldkF0b21TdGF0ZTtcbiAgICB9XG4gICAgc2V0QXRvbVN0YXRlKGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgICBpZiAoYSAhPT0gYXRvbSAmJiAhbW91bnRlZE1hcC5oYXMoYSkpIHtcbiAgICAgICAgICByZWFkQXRvbVN0YXRlKGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChBcnJheS5mcm9tKGF0b21TdGF0ZS5kKS5ldmVyeShcbiAgICAgICAgKFthLCBzXSkgPT4gYSA9PT0gYXRvbSB8fCBnZXRBdG9tU3RhdGUoYSkgPT09IHNcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVwU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBnZXR0ZXIgPSAoYSkgPT4ge1xuICAgICAgZGVwU2V0LmFkZChhKTtcbiAgICAgIGlmIChhID09PSBhdG9tKSB7XG4gICAgICAgIGNvbnN0IGFTdGF0ZTIgPSBnZXRBdG9tU3RhdGUoYSk7XG4gICAgICAgIGlmIChhU3RhdGUyKSB7XG4gICAgICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGEuaW5pdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBhdG9tIGluaXRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKGEpO1xuICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUpO1xuICAgIH07XG4gICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgbGV0IHNldFNlbGY7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgfSxcbiAgICAgIGdldCBzZXRTZWxmKCkge1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiICYmICFpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlYWQtb25seSBhdG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2V0U2VsZiAmJiBpc0FjdHVhbGx5V3JpdGFibGVBdG9tKGF0b20pKSB7XG4gICAgICAgICAgc2V0U2VsZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiICYmIGlzU3luYykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgaW4gc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgICAgIHJldHVybiB3cml0ZUF0b20oYXRvbSwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0U2VsZjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0b20ucmVhZChnZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBsZXQgY29udGludWVQcm9taXNlO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGxldCBzZXR0bGVkID0gZmFsc2U7XG4gICAgICAgICAgdmFsdWUudGhlbihcbiAgICAgICAgICAgICh2KSA9PiB7XG4gICAgICAgICAgICAgIGlmICghc2V0dGxlZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKHByb21pc2UsIHYpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHByb21pc2UsIGUpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIHNldEF0b21WYWx1ZShhdG9tLCBwcm9taXNlLCBkZXBTZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlUHJvbWlzZSA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNldHRsZWQpIHtcbiAgICAgICAgICAgICAgc2V0dGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIG5leHQudGhlbihcbiAgICAgICAgICAgICAgICAodikgPT4gcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgdiksXG4gICAgICAgICAgICAgICAgKGUpID0+IHJlamVjdFByb21pc2UocHJvbWlzZSwgZSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgcmVnaXN0ZXJDYW5jZWxQcm9taXNlKHByb21pc2UsIChuZXh0KSA9PiB7XG4gICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlUHJvbWlzZShuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCBwcm9taXNlLCBkZXBTZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldEF0b21WYWx1ZShhdG9tLCB2YWx1ZSwgZGVwU2V0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHNldEF0b21FcnJvcihhdG9tLCBlcnJvciwgZGVwU2V0KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWFkQXRvbSA9IChhdG9tKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhdG9tKSk7XG4gIGNvbnN0IGFkZEF0b20gPSAoYXRvbSkgPT4ge1xuICAgIGxldCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKCFtb3VudGVkKSB7XG4gICAgICBtb3VudGVkID0gbW91bnRBdG9tKGF0b20pO1xuICAgIH1cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfTtcbiAgY29uc3QgY2FuVW5tb3VudEF0b20gPSAoYXRvbSwgbW91bnRlZCkgPT4gIW1vdW50ZWQubC5zaXplICYmICghbW91bnRlZC50LnNpemUgfHwgbW91bnRlZC50LnNpemUgPT09IDEgJiYgbW91bnRlZC50LmhhcyhhdG9tKSk7XG4gIGNvbnN0IGRlbEF0b20gPSAoYXRvbSkgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICBpZiAobW91bnRlZCAmJiBjYW5Vbm1vdW50QXRvbShhdG9tLCBtb3VudGVkKSkge1xuICAgICAgdW5tb3VudEF0b20oYXRvbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWNvbXB1dGVEZXBlbmRlbnRzID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYXRvbSk7XG4gICAgbW91bnRlZCA9PSBudWxsID8gdm9pZCAwIDogbW91bnRlZC50LmZvckVhY2goKGRlcGVuZGVudCkgPT4ge1xuICAgICAgaWYgKGRlcGVuZGVudCAhPT0gYXRvbSkge1xuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGRlcGVuZGVudCk7XG4gICAgICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSByZWFkQXRvbVN0YXRlKGRlcGVuZGVudCk7XG4gICAgICAgIGlmICghcHJldkF0b21TdGF0ZSB8fCAhaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBuZXh0QXRvbVN0YXRlKSkge1xuICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoZGVwZW5kZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9IChhdG9tLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGlzU3luYyA9IHRydWU7XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHJldHVybkF0b21WYWx1ZShyZWFkQXRvbVN0YXRlKGEpKTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgLi4uYXJnczIpID0+IHtcbiAgICAgIGxldCByO1xuICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdG9tIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKGEpO1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVZhbHVlKGEsIGFyZ3MyWzBdKTtcbiAgICAgICAgaWYgKCFwcmV2QXRvbVN0YXRlIHx8ICFpc0VxdWFsQXRvbVZhbHVlKHByZXZBdG9tU3RhdGUsIG5leHRBdG9tU3RhdGUpKSB7XG4gICAgICAgICAgcmVjb21wdXRlRGVwZW5kZW50cyhhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHdyaXRlQXRvbVN0YXRlKGEsIC4uLmFyZ3MyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgIGZsdXNoUGVuZGluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBhdG9tLndyaXRlKGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb25zdCB3cml0ZUF0b20gPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHdyaXRlQXRvbVN0YXRlKGF0b20sIC4uLmFyZ3MpO1xuICAgIGZsdXNoUGVuZGluZygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IG1vdW50QXRvbSA9IChhdG9tLCBpbml0aWFsRGVwZW5kZW50KSA9PiB7XG4gICAgY29uc3QgbW91bnRlZCA9IHtcbiAgICAgIHQ6IG5ldyBTZXQoaW5pdGlhbERlcGVuZGVudCAmJiBbaW5pdGlhbERlcGVuZGVudF0pLFxuICAgICAgbDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgbW91bnRlZE1hcC5zZXQoYXRvbSwgbW91bnRlZCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgbW91bnRlZEF0b21zLmFkZChhdG9tKTtcbiAgICB9XG4gICAgcmVhZEF0b21TdGF0ZShhdG9tKS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgIGNvbnN0IGFNb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICBpZiAoYU1vdW50ZWQpIHtcbiAgICAgICAgYU1vdW50ZWQudC5hZGQoYXRvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYSAhPT0gYXRvbSkge1xuICAgICAgICAgIG1vdW50QXRvbShhLCBhdG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlYWRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkgJiYgYXRvbS5vbk1vdW50KSB7XG4gICAgICBjb25zdCBvblVubW91bnQgPSBhdG9tLm9uTW91bnQoKC4uLmFyZ3MpID0+IHdyaXRlQXRvbShhdG9tLCAuLi5hcmdzKSk7XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIG1vdW50ZWQudSA9IG9uVW5tb3VudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH07XG4gIGNvbnN0IHVubW91bnRBdG9tID0gKGF0b20pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb25Vbm1vdW50ID0gKF9hID0gbW91bnRlZE1hcC5nZXQoYXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS51O1xuICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgIG9uVW5tb3VudCgpO1xuICAgIH1cbiAgICBtb3VudGVkTWFwLmRlbGV0ZShhdG9tKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuZGVsZXRlKGF0b20pO1xuICAgIH1cbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgaWYgKGhhc1Byb21pc2VBdG9tVmFsdWUoYXRvbVN0YXRlKSkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKGF0b21TdGF0ZS52KTtcbiAgICAgIH1cbiAgICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICAgICAgICBpZiAoY2FuVW5tb3VudEF0b20oYSwgbW91bnRlZCkpIHtcbiAgICAgICAgICAgICAgdW5tb3VudEF0b20oYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gY291bGQgbm90IGZpbmQgYXRvbSBzdGF0ZSB0byB1bm1vdW50XCIsIGF0b20pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnREZXBlbmRlbmNpZXMgPSAoYXRvbSwgYXRvbVN0YXRlLCBwcmV2RGVwZW5kZW5jaWVzKSA9PiB7XG4gICAgY29uc3QgZGVwU2V0ID0gbmV3IFNldChhdG9tU3RhdGUuZC5rZXlzKCkpO1xuICAgIHByZXZEZXBlbmRlbmNpZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZEZXBlbmRlbmNpZXMuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgaWYgKGRlcFNldC5oYXMoYSkpIHtcbiAgICAgICAgZGVwU2V0LmRlbGV0ZShhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgaWYgKGNhblVubW91bnRBdG9tKGEsIG1vdW50ZWQpKSB7XG4gICAgICAgICAgdW5tb3VudEF0b20oYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZXBTZXQuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgIH0gZWxzZSBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkpIHtcbiAgICAgICAgbW91bnRBdG9tKGEsIGF0b20pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBmbHVzaFBlbmRpbmcgPSAoKSA9PiB7XG4gICAgd2hpbGUgKHBlbmRpbmdNYXAuc2l6ZSkge1xuICAgICAgY29uc3QgcGVuZGluZyA9IEFycmF5LmZyb20ocGVuZGluZ01hcCk7XG4gICAgICBwZW5kaW5nTWFwLmNsZWFyKCk7XG4gICAgICBwZW5kaW5nLmZvckVhY2goKFthdG9tLCBwcmV2QXRvbVN0YXRlXSkgPT4ge1xuICAgICAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICAgIGlmIChhdG9tU3RhdGUpIHtcbiAgICAgICAgICBpZiAoYXRvbVN0YXRlLmQgIT09IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpKSB7XG4gICAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyhhdG9tLCBhdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICAgICAgICBpZiAobW91bnRlZCAmJiAhLy8gVE9ETyBUaGlzIHNlZW1zIHByZXR0eSBoYWNreS4gSG9wZSB0byBmaXggaXQuXG4gICAgICAgICAgLy8gTWF5YmUgd2UgY291bGQgYG1vdW50RGVwZW5kZW5jaWVzYCBpbiBgc2V0QXRvbVN0YXRlYD9cbiAgICAgICAgICAocHJldkF0b21TdGF0ZSAmJiAhaGFzUHJvbWlzZUF0b21WYWx1ZShwcmV2QXRvbVN0YXRlKSAmJiAoaXNFcXVhbEF0b21WYWx1ZShwcmV2QXRvbVN0YXRlLCBhdG9tU3RhdGUpIHx8IGlzRXF1YWxBdG9tRXJyb3IocHJldkF0b21TdGF0ZSwgYXRvbVN0YXRlKSkpKSB7XG4gICAgICAgICAgICBtb3VudGVkLmwuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBubyBhdG9tIHN0YXRlIHRvIGZsdXNoXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgc3RhdGVMaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4gbCgpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZUF0b20gPSAoYXRvbSwgbGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gYWRkQXRvbShhdG9tKTtcbiAgICBmbHVzaFBlbmRpbmcoKTtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBtb3VudGVkLmw7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgZGVsQXRvbShhdG9tKTtcbiAgICB9O1xuICB9O1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldDogcmVhZEF0b20sXG4gICAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICAgIHN1Yjogc3Vic2NyaWJlQXRvbSxcbiAgICAgIC8vIHN0b3JlIGRldiBtZXRob2RzICh0aGVzZSBhcmUgdGVudGF0aXZlIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSlcbiAgICAgIGRldl9zdWJzY3JpYmVfc3RhdGU6IChsKSA9PiB7XG4gICAgICAgIHN0YXRlTGlzdGVuZXJzLmFkZChsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBzdGF0ZUxpc3RlbmVycy5kZWxldGUobCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZGV2X2dldF9tb3VudGVkX2F0b21zOiAoKSA9PiBtb3VudGVkQXRvbXMudmFsdWVzKCksXG4gICAgICBkZXZfZ2V0X2F0b21fc3RhdGU6IChhKSA9PiBhdG9tU3RhdGVNYXAuZ2V0KGEpLFxuICAgICAgZGV2X2dldF9tb3VudGVkOiAoYSkgPT4gbW91bnRlZE1hcC5nZXQoYSksXG4gICAgICBkZXZfcmVzdG9yZV9hdG9tczogKHZhbHVlcykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFthdG9tLCB2YWx1ZV0gb2YgdmFsdWVzKSB7XG4gICAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhdG9tKSkge1xuICAgICAgICAgICAgc2V0QXRvbVZhbHVlKGF0b20sIHZhbHVlKTtcbiAgICAgICAgICAgIHJlY29tcHV0ZURlcGVuZGVudHMoYXRvbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZsdXNoUGVuZGluZygpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXQ6IHJlYWRBdG9tLFxuICAgIHNldDogd3JpdGVBdG9tLFxuICAgIHN1Yjogc3Vic2NyaWJlQXRvbVxuICB9O1xufTtcbmxldCBkZWZhdWx0U3RvcmU7XG5jb25zdCBnZXREZWZhdWx0U3RvcmUgPSAoKSA9PiB7XG4gIGlmICghZGVmYXVsdFN0b3JlKSB7XG4gICAgZGVmYXVsdFN0b3JlID0gY3JlYXRlU3RvcmUoKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufTtcblxuZXhwb3J0IHsgYXRvbSwgY3JlYXRlU3RvcmUsIGdldERlZmF1bHRTdG9yZSB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCBjcmVhdGVFbGVtZW50LCB1c2VDb250ZXh0LCB1c2VSZWR1Y2VyLCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGF0b20gYXMgYXRvbSQxIH0gZnJvbSAnam90YWkvdmFuaWxsYSc7XG5cbmNvbnN0IFNVU1BFTlNFX1BST01JU0UgPSBTeW1ib2woKTtcbmNvbnN0IGlzU3VzcGVuc2VQcm9taXNlID0gKHByb21pc2UpID0+ICEhcHJvbWlzZVtTVVNQRU5TRV9QUk9NSVNFXTtcbmNvbnN0IGlzU3VzcGVuc2VQcm9taXNlQWxyZWFkeUNhbmNlbGxlZCA9IChzdXNwZW5zZVByb21pc2UpID0+ICFzdXNwZW5zZVByb21pc2VbU1VTUEVOU0VfUFJPTUlTRV0uYztcbmNvbnN0IGNhbmNlbFN1c3BlbnNlUHJvbWlzZSA9IChzdXNwZW5zZVByb21pc2UpID0+IHtcbiAgdmFyIF9hO1xuICBjb25zdCB7IGI6IGJhc2VQcm9taXNlLCBjOiBjYW5jZWxQcm9taXNlIH0gPSBzdXNwZW5zZVByb21pc2VbU1VTUEVOU0VfUFJPTUlTRV07XG4gIGlmIChjYW5jZWxQcm9taXNlKSB7XG4gICAgY2FuY2VsUHJvbWlzZSgpO1xuICAgIChfYSA9IHByb21pc2VBYm9ydE1hcC5nZXQoYmFzZVByb21pc2UpKSA9PSBudWxsID8gdm9pZCAwIDogX2EoKTtcbiAgfVxufTtcbmNvbnN0IGlzRXF1YWxTdXNwZW5zZVByb21pc2UgPSAob2xkU3VzcGVuc2VQcm9taXNlLCBuZXdTdXNwZW5zZVByb21pc2UpID0+IHtcbiAgY29uc3Qgb2xkT3JpZ2luYWxQcm9taXNlID0gb2xkU3VzcGVuc2VQcm9taXNlW1NVU1BFTlNFX1BST01JU0VdLm87XG4gIGNvbnN0IG5ld09yaWdpbmFsUHJvbWlzZSA9IG5ld1N1c3BlbnNlUHJvbWlzZVtTVVNQRU5TRV9QUk9NSVNFXS5vO1xuICByZXR1cm4gb2xkT3JpZ2luYWxQcm9taXNlID09PSBuZXdPcmlnaW5hbFByb21pc2UgfHwgb2xkU3VzcGVuc2VQcm9taXNlID09PSBuZXdPcmlnaW5hbFByb21pc2UgfHwgaXNTdXNwZW5zZVByb21pc2Uob2xkT3JpZ2luYWxQcm9taXNlKSAmJiBpc0VxdWFsU3VzcGVuc2VQcm9taXNlKG9sZE9yaWdpbmFsUHJvbWlzZSwgbmV3U3VzcGVuc2VQcm9taXNlKTtcbn07XG5jb25zdCBjcmVhdGVTdXNwZW5zZVByb21pc2UgPSAoYmFzZVByb21pc2UsIHByb21pc2UpID0+IHtcbiAgY29uc3Qgc3VzcGVuc2VQcm9taXNlRXh0cmEgPSB7XG4gICAgYjogYmFzZVByb21pc2UsXG4gICAgbzogcHJvbWlzZSxcbiAgICBjOiBudWxsXG4gIH07XG4gIGNvbnN0IHN1c3BlbnNlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc3VzcGVuc2VQcm9taXNlRXh0cmEuYyA9ICgpID0+IHtcbiAgICAgIHN1c3BlbnNlUHJvbWlzZUV4dHJhLmMgPSBudWxsO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcHJvbWlzZS5maW5hbGx5KHN1c3BlbnNlUHJvbWlzZUV4dHJhLmMpO1xuICB9KTtcbiAgc3VzcGVuc2VQcm9taXNlW1NVU1BFTlNFX1BST01JU0VdID0gc3VzcGVuc2VQcm9taXNlRXh0cmE7XG4gIHJldHVybiBzdXNwZW5zZVByb21pc2U7XG59O1xuY29uc3QgY29weVN1c3BlbnNlUHJvbWlzZSA9IChzdXNwZW5zZVByb21pc2UpID0+IGNyZWF0ZVN1c3BlbnNlUHJvbWlzZShcbiAgc3VzcGVuc2VQcm9taXNlW1NVU1BFTlNFX1BST01JU0VdLmIsXG4gIHN1c3BlbnNlUHJvbWlzZVtTVVNQRU5TRV9QUk9NSVNFXS5vXG4pO1xuY29uc3QgcHJvbWlzZUFib3J0TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZWdpc3RlclByb21pc2VBYm9ydCA9IChiYXNlUHJvbWlzZSwgYWJvcnQpID0+IHtcbiAgcHJvbWlzZUFib3J0TWFwLnNldChiYXNlUHJvbWlzZSwgYWJvcnQpO1xufTtcblxuY29uc3QgaGFzSW5pdGlhbFZhbHVlID0gKGF0b20pID0+IFwiaW5pdFwiIGluIGF0b207XG5jb25zdCBSRUFEX0FUT00gPSBcInJcIjtcbmNvbnN0IFdSSVRFX0FUT00gPSBcIndcIjtcbmNvbnN0IENPTU1JVF9BVE9NID0gXCJjXCI7XG5jb25zdCBTVUJTQ1JJQkVfQVRPTSA9IFwic1wiO1xuY29uc3QgUkVTVE9SRV9BVE9NUyA9IFwiaFwiO1xuY29uc3QgREVWX1NVQlNDUklCRV9TVEFURSA9IFwiblwiO1xuY29uc3QgREVWX0dFVF9NT1VOVEVEX0FUT01TID0gXCJsXCI7XG5jb25zdCBERVZfR0VUX0FUT01fU1RBVEUgPSBcImFcIjtcbmNvbnN0IERFVl9HRVRfTU9VTlRFRCA9IFwibVwiO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW5pdGlhbFZhbHVlcykgPT4ge1xuICBjb25zdCBjb21taXR0ZWRBdG9tU3RhdGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgbW91bnRlZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBwZW5kaW5nTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IHN0YXRlTGlzdGVuZXJzO1xuICBsZXQgbW91bnRlZEF0b21zO1xuICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgc3RhdGVMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIG1vdW50ZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgaWYgKGluaXRpYWxWYWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFthdG9tLCB2YWx1ZV0gb2YgaW5pdGlhbFZhbHVlcykge1xuICAgICAgY29uc3QgYXRvbVN0YXRlID0ge1xuICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgcjogMCxcbiAgICAgICAgeTogdHJ1ZSxcbiAgICAgICAgLy8gbm90IGludmFsaWRhdGVkXG4gICAgICAgIGQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgICAgIH07XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoYXRvbVN0YXRlKTtcbiAgICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIkZvdW5kIGluaXRpYWwgdmFsdWUgZm9yIGRlcml2ZWQgYXRvbSB3aGljaCBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvclwiLFxuICAgICAgICAgICAgYXRvbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbW1pdHRlZEF0b21TdGF0ZU1hcC5zZXQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3VzcGVuc2VQcm9taXNlQ2FjaGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgYWRkU3VzcGVuc2VQcm9taXNlVG9DYWNoZSA9ICh2ZXJzaW9uLCBhdG9tLCBzdXNwZW5zZVByb21pc2UpID0+IHtcbiAgICBsZXQgY2FjaGUgPSBzdXNwZW5zZVByb21pc2VDYWNoZU1hcC5nZXQoYXRvbSk7XG4gICAgaWYgKCFjYWNoZSkge1xuICAgICAgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgc3VzcGVuc2VQcm9taXNlQ2FjaGVNYXAuc2V0KGF0b20sIGNhY2hlKTtcbiAgICB9XG4gICAgc3VzcGVuc2VQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGNhY2hlLmdldCh2ZXJzaW9uKSA9PT0gc3VzcGVuc2VQcm9taXNlKSB7XG4gICAgICAgIGNhY2hlLmRlbGV0ZSh2ZXJzaW9uKTtcbiAgICAgICAgaWYgKCFjYWNoZS5zaXplKSB7XG4gICAgICAgICAgc3VzcGVuc2VQcm9taXNlQ2FjaGVNYXAuZGVsZXRlKGF0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2FjaGUuc2V0KHZlcnNpb24sIHN1c3BlbnNlUHJvbWlzZSk7XG4gIH07XG4gIGNvbnN0IGNhbmNlbEFsbFN1c3BlbnNlUHJvbWlzZUluQ2FjaGUgPSAoYXRvbSkgPT4ge1xuICAgIGNvbnN0IHZlcnNpb25TZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGNhY2hlID0gc3VzcGVuc2VQcm9taXNlQ2FjaGVNYXAuZ2V0KGF0b20pO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgc3VzcGVuc2VQcm9taXNlQ2FjaGVNYXAuZGVsZXRlKGF0b20pO1xuICAgICAgY2FjaGUuZm9yRWFjaCgoc3VzcGVuc2VQcm9taXNlLCB2ZXJzaW9uKSA9PiB7XG4gICAgICAgIGNhbmNlbFN1c3BlbnNlUHJvbWlzZShzdXNwZW5zZVByb21pc2UpO1xuICAgICAgICB2ZXJzaW9uU2V0LmFkZCh2ZXJzaW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmVyc2lvblNldDtcbiAgfTtcbiAgY29uc3QgdmVyc2lvbmVkQXRvbVN0YXRlTWFwTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IGdldFZlcnNpb25lZEF0b21TdGF0ZU1hcCA9ICh2ZXJzaW9uKSA9PiB7XG4gICAgbGV0IHZlcnNpb25lZEF0b21TdGF0ZU1hcCA9IHZlcnNpb25lZEF0b21TdGF0ZU1hcE1hcC5nZXQodmVyc2lvbik7XG4gICAgaWYgKCF2ZXJzaW9uZWRBdG9tU3RhdGVNYXApIHtcbiAgICAgIHZlcnNpb25lZEF0b21TdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB2ZXJzaW9uZWRBdG9tU3RhdGVNYXBNYXAuc2V0KHZlcnNpb24sIHZlcnNpb25lZEF0b21TdGF0ZU1hcCk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJzaW9uZWRBdG9tU3RhdGVNYXA7XG4gIH07XG4gIGNvbnN0IGdldEF0b21TdGF0ZSA9ICh2ZXJzaW9uLCBhdG9tKSA9PiB7XG4gICAgaWYgKHZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHZlcnNpb25lZEF0b21TdGF0ZU1hcCA9IGdldFZlcnNpb25lZEF0b21TdGF0ZU1hcCh2ZXJzaW9uKTtcbiAgICAgIGxldCBhdG9tU3RhdGUgPSB2ZXJzaW9uZWRBdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICAgICAgaWYgKCFhdG9tU3RhdGUpIHtcbiAgICAgICAgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKHZlcnNpb24ucCwgYXRvbSk7XG4gICAgICAgIGlmIChhdG9tU3RhdGUgJiYgXCJwXCIgaW4gYXRvbVN0YXRlICYmIGlzU3VzcGVuc2VQcm9taXNlQWxyZWFkeUNhbmNlbGxlZChhdG9tU3RhdGUucCkpIHtcbiAgICAgICAgICBhdG9tU3RhdGUgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b21TdGF0ZSkge1xuICAgICAgICAgIHZlcnNpb25lZEF0b21TdGF0ZU1hcC5zZXQoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1pdHRlZEF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gIH07XG4gIGNvbnN0IHNldEF0b21TdGF0ZSA9ICh2ZXJzaW9uLCBhdG9tLCBhdG9tU3RhdGUpID0+IHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGF0b21TdGF0ZSk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uZWRBdG9tU3RhdGVNYXAgPSBnZXRWZXJzaW9uZWRBdG9tU3RhdGVNYXAodmVyc2lvbik7XG4gICAgICB2ZXJzaW9uZWRBdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZBdG9tU3RhdGUgPSBjb21taXR0ZWRBdG9tU3RhdGVNYXAuZ2V0KGF0b20pO1xuICAgICAgY29tbWl0dGVkQXRvbVN0YXRlTWFwLnNldChhdG9tLCBhdG9tU3RhdGUpO1xuICAgICAgaWYgKCFwZW5kaW5nTWFwLmhhcyhhdG9tKSkge1xuICAgICAgICBwZW5kaW5nTWFwLnNldChhdG9tLCBwcmV2QXRvbVN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IGNyZWF0ZVJlYWREZXBlbmRlbmNpZXMgPSAodmVyc2lvbiwgcHJldlJlYWREZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBkZXBlbmRlbmNpZXMpID0+IHtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgcmV0dXJuIHByZXZSZWFkRGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBjb25zdCByZWFkRGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKChhdG9tKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCByZXZpc2lvbiA9ICgoX2EgPSBnZXRBdG9tU3RhdGUodmVyc2lvbiwgYXRvbSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yKSB8fCAwO1xuICAgICAgcmVhZERlcGVuZGVuY2llcy5zZXQoYXRvbSwgcmV2aXNpb24pO1xuICAgICAgaWYgKHByZXZSZWFkRGVwZW5kZW5jaWVzLmdldChhdG9tKSAhPT0gcmV2aXNpb24pIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHByZXZSZWFkRGVwZW5kZW5jaWVzLnNpemUgPT09IHJlYWREZXBlbmRlbmNpZXMuc2l6ZSAmJiAhY2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHByZXZSZWFkRGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVhZERlcGVuZGVuY2llcztcbiAgfTtcbiAgY29uc3Qgc2V0QXRvbVZhbHVlID0gKHZlcnNpb24sIGF0b20sIHZhbHVlLCBkZXBlbmRlbmNpZXMsIHN1c3BlbnNlUHJvbWlzZSkgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZSh2ZXJzaW9uLCBhdG9tKTtcbiAgICBpZiAoYXRvbVN0YXRlKSB7XG4gICAgICBpZiAoc3VzcGVuc2VQcm9taXNlICYmICghKFwicFwiIGluIGF0b21TdGF0ZSkgfHwgIWlzRXF1YWxTdXNwZW5zZVByb21pc2UoYXRvbVN0YXRlLnAsIHN1c3BlbnNlUHJvbWlzZSkpKSB7XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgICBpZiAoXCJwXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgICAgIGNhbmNlbFN1c3BlbnNlUHJvbWlzZShhdG9tU3RhdGUucCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICB2OiB2YWx1ZSxcbiAgICAgIHI6IChhdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGF0b21TdGF0ZS5yKSB8fCAwLFxuICAgICAgeTogdHJ1ZSxcbiAgICAgIC8vIG5vdCBpbnZhbGlkYXRlZFxuICAgICAgZDogY3JlYXRlUmVhZERlcGVuZGVuY2llcyh2ZXJzaW9uLCBhdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGF0b21TdGF0ZS5kLCBkZXBlbmRlbmNpZXMpXG4gICAgfTtcbiAgICBsZXQgY2hhbmdlZCA9ICEoYXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBhdG9tU3RhdGUueSk7XG4gICAgaWYgKCFhdG9tU3RhdGUgfHwgIShcInZcIiBpbiBhdG9tU3RhdGUpIHx8IC8vIG5ldyB2YWx1ZSwgb3JcbiAgICAhT2JqZWN0LmlzKGF0b21TdGF0ZS52LCB2YWx1ZSkpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgKytuZXh0QXRvbVN0YXRlLnI7XG4gICAgICBpZiAobmV4dEF0b21TdGF0ZS5kLmhhcyhhdG9tKSkge1xuICAgICAgICBuZXh0QXRvbVN0YXRlLmQgPSBuZXcgTWFwKG5leHRBdG9tU3RhdGUuZCkuc2V0KGF0b20sIG5leHRBdG9tU3RhdGUucik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0QXRvbVN0YXRlLmQgIT09IGF0b21TdGF0ZS5kICYmIChuZXh0QXRvbVN0YXRlLmQuc2l6ZSAhPT0gYXRvbVN0YXRlLmQuc2l6ZSB8fCAhQXJyYXkuZnJvbShuZXh0QXRvbVN0YXRlLmQua2V5cygpKS5ldmVyeSgoYSkgPT4gYXRvbVN0YXRlLmQuaGFzKGEpKSkpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGZsdXNoUGVuZGluZyh2ZXJzaW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYXRvbVN0YXRlICYmICFjaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgIH1cbiAgICBzZXRBdG9tU3RhdGUodmVyc2lvbiwgYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHNldEF0b21SZWFkRXJyb3IgPSAodmVyc2lvbiwgYXRvbSwgZXJyb3IsIGRlcGVuZGVuY2llcywgc3VzcGVuc2VQcm9taXNlKSA9PiB7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKHZlcnNpb24sIGF0b20pO1xuICAgIGlmIChhdG9tU3RhdGUpIHtcbiAgICAgIGlmIChzdXNwZW5zZVByb21pc2UgJiYgKCEoXCJwXCIgaW4gYXRvbVN0YXRlKSB8fCAhaXNFcXVhbFN1c3BlbnNlUHJvbWlzZShhdG9tU3RhdGUucCwgc3VzcGVuc2VQcm9taXNlKSkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcInBcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgICAgY2FuY2VsU3VzcGVuc2VQcm9taXNlKGF0b21TdGF0ZS5wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV4dEF0b21TdGF0ZSA9IHtcbiAgICAgIGU6IGVycm9yLFxuICAgICAgLy8gc2V0IHJlYWQgZXJyb3JcbiAgICAgIHI6ICgoYXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBhdG9tU3RhdGUucikgfHwgMCkgKyAxLFxuICAgICAgeTogdHJ1ZSxcbiAgICAgIC8vIG5vdCBpbnZhbGlkYXRlZFxuICAgICAgZDogY3JlYXRlUmVhZERlcGVuZGVuY2llcyh2ZXJzaW9uLCBhdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGF0b21TdGF0ZS5kLCBkZXBlbmRlbmNpZXMpXG4gICAgfTtcbiAgICBzZXRBdG9tU3RhdGUodmVyc2lvbiwgYXRvbSwgbmV4dEF0b21TdGF0ZSk7XG4gICAgcmV0dXJuIG5leHRBdG9tU3RhdGU7XG4gIH07XG4gIGNvbnN0IHNldEF0b21TdXNwZW5zZVByb21pc2UgPSAodmVyc2lvbiwgYXRvbSwgc3VzcGVuc2VQcm9taXNlLCBkZXBlbmRlbmNpZXMpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUodmVyc2lvbiwgYXRvbSk7XG4gICAgaWYgKGF0b21TdGF0ZSAmJiBcInBcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgIGlmIChpc0VxdWFsU3VzcGVuc2VQcm9taXNlKGF0b21TdGF0ZS5wLCBzdXNwZW5zZVByb21pc2UpICYmICFpc1N1c3BlbnNlUHJvbWlzZUFscmVhZHlDYW5jZWxsZWQoYXRvbVN0YXRlLnApKSB7XG4gICAgICAgIGlmICghYXRvbVN0YXRlLnkpIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5hdG9tU3RhdGUsIHk6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXRvbVN0YXRlO1xuICAgICAgfVxuICAgICAgY2FuY2VsU3VzcGVuc2VQcm9taXNlKGF0b21TdGF0ZS5wKTtcbiAgICB9XG4gICAgYWRkU3VzcGVuc2VQcm9taXNlVG9DYWNoZSh2ZXJzaW9uLCBhdG9tLCBzdXNwZW5zZVByb21pc2UpO1xuICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICBwOiBzdXNwZW5zZVByb21pc2UsXG4gICAgICByOiAoKGF0b21TdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogYXRvbVN0YXRlLnIpIHx8IDApICsgMSxcbiAgICAgIHk6IHRydWUsXG4gICAgICAvLyBub3QgaW52YWxpZGF0ZWRcbiAgICAgIGQ6IGNyZWF0ZVJlYWREZXBlbmRlbmNpZXModmVyc2lvbiwgYXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBhdG9tU3RhdGUuZCwgZGVwZW5kZW5jaWVzKVxuICAgIH07XG4gICAgc2V0QXRvbVN0YXRlKHZlcnNpb24sIGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIHJldHVybiBuZXh0QXRvbVN0YXRlO1xuICB9O1xuICBjb25zdCBzZXRBdG9tUHJvbWlzZU9yVmFsdWUgPSAodmVyc2lvbiwgYXRvbSwgcHJvbWlzZU9yVmFsdWUsIGRlcGVuZGVuY2llcykgPT4ge1xuICAgIGlmIChwcm9taXNlT3JWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIGNvbnN0IHN1c3BlbnNlUHJvbWlzZSA9IGNyZWF0ZVN1c3BlbnNlUHJvbWlzZShcbiAgICAgICAgcHJvbWlzZU9yVmFsdWUsXG4gICAgICAgIHByb21pc2VPclZhbHVlLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2V0QXRvbVZhbHVlKHZlcnNpb24sIGF0b20sIHZhbHVlLCBkZXBlbmRlbmNpZXMsIHN1c3BlbnNlUHJvbWlzZSk7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBpZiAoaXNTdXNwZW5zZVByb21pc2UoZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGUudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVhZEF0b21TdGF0ZSh2ZXJzaW9uLCBhdG9tLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0QXRvbVJlYWRFcnJvcih2ZXJzaW9uLCBhdG9tLCBlLCBkZXBlbmRlbmNpZXMsIHN1c3BlbnNlUHJvbWlzZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNldEF0b21TdXNwZW5zZVByb21pc2UoXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGF0b20sXG4gICAgICAgIHN1c3BlbnNlUHJvbWlzZSxcbiAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gc2V0QXRvbVZhbHVlKFxuICAgICAgdmVyc2lvbixcbiAgICAgIGF0b20sXG4gICAgICBwcm9taXNlT3JWYWx1ZSxcbiAgICAgIGRlcGVuZGVuY2llc1xuICAgICk7XG4gIH07XG4gIGNvbnN0IHNldEF0b21JbnZhbGlkYXRlZCA9ICh2ZXJzaW9uLCBhdG9tKSA9PiB7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKHZlcnNpb24sIGF0b20pO1xuICAgIGlmIChhdG9tU3RhdGUpIHtcbiAgICAgIGNvbnN0IG5leHRBdG9tU3RhdGUgPSB7XG4gICAgICAgIC4uLmF0b21TdGF0ZSxcbiAgICAgICAgLy8gY29weSBldmVyeXRoaW5nXG4gICAgICAgIHk6IGZhbHNlXG4gICAgICAgIC8vIGludmFsaWRhdGVkXG4gICAgICB9O1xuICAgICAgc2V0QXRvbVN0YXRlKHZlcnNpb24sIGF0b20sIG5leHRBdG9tU3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbQnVnXSBjb3VsZCBub3QgaW52YWxpZGF0ZSBub24gZXhpc3RpbmcgYXRvbVwiLCBhdG9tKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tU3RhdGUgPSAodmVyc2lvbiwgYXRvbSwgZm9yY2UpID0+IHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBjb25zdCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUodmVyc2lvbiwgYXRvbSk7XG4gICAgICBpZiAoYXRvbVN0YXRlKSB7XG4gICAgICAgIGlmIChhdG9tU3RhdGUueSAmJiAvLyBub3QgaW52YWxpZGF0ZWRcbiAgICAgICAgXCJwXCIgaW4gYXRvbVN0YXRlICYmICFpc1N1c3BlbnNlUHJvbWlzZUFscmVhZHlDYW5jZWxsZWQoYXRvbVN0YXRlLnApKSB7XG4gICAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBhdG9tU3RhdGUuZC5mb3JFYWNoKChfLCBhKSA9PiB7XG4gICAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICAgIGlmICghbW91bnRlZE1hcC5oYXMoYSkpIHtcbiAgICAgICAgICAgICAgcmVhZEF0b21TdGF0ZSh2ZXJzaW9uLCBhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldEF0b21TdGF0ZSh2ZXJzaW9uLCBhKTtcbiAgICAgICAgICAgICAgaWYgKGFTdGF0ZSAmJiAhYVN0YXRlLnkpIHtcbiAgICAgICAgICAgICAgICByZWFkQXRvbVN0YXRlKHZlcnNpb24sIGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKEFycmF5LmZyb20oYXRvbVN0YXRlLmQpLmV2ZXJ5KChbYSwgcl0pID0+IHtcbiAgICAgICAgICBjb25zdCBhU3RhdGUgPSBnZXRBdG9tU3RhdGUodmVyc2lvbiwgYSk7XG4gICAgICAgICAgcmV0dXJuIGFTdGF0ZSAmJiAhKFwicFwiIGluIGFTdGF0ZSkgJiYgLy8gaGFzIG5vIHN1c3BlbnNlIHByb21pc2VcbiAgICAgICAgICBhU3RhdGUuciA9PT0gcjtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBpZiAoIWF0b21TdGF0ZS55KSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hdG9tU3RhdGUsIHk6IHRydWUgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlT3JWYWx1ZSA9IGF0b20ucmVhZCgoYSkgPT4ge1xuICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKGEpO1xuICAgICAgICBjb25zdCBhU3RhdGUgPSBhID09PSBhdG9tID8gZ2V0QXRvbVN0YXRlKHZlcnNpb24sIGEpIDogcmVhZEF0b21TdGF0ZSh2ZXJzaW9uLCBhKTtcbiAgICAgICAgaWYgKGFTdGF0ZSkge1xuICAgICAgICAgIGlmIChcImVcIiBpbiBhU3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IGFTdGF0ZS5lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJwXCIgaW4gYVN0YXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBhU3RhdGUucDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFTdGF0ZS52O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICByZXR1cm4gYS5pbml0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGF0b20gaW5pdFwiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNldEF0b21Qcm9taXNlT3JWYWx1ZSh2ZXJzaW9uLCBhdG9tLCBwcm9taXNlT3JWYWx1ZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9IGNhdGNoIChlcnJvck9yUHJvbWlzZSkge1xuICAgICAgaWYgKGVycm9yT3JQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBjb25zdCBzdXNwZW5zZVByb21pc2UgPSBpc1N1c3BlbnNlUHJvbWlzZShlcnJvck9yUHJvbWlzZSkgJiYgaXNTdXNwZW5zZVByb21pc2VBbHJlYWR5Q2FuY2VsbGVkKGVycm9yT3JQcm9taXNlKSA/IGNvcHlTdXNwZW5zZVByb21pc2UoZXJyb3JPclByb21pc2UpIDogY3JlYXRlU3VzcGVuc2VQcm9taXNlKGVycm9yT3JQcm9taXNlLCBlcnJvck9yUHJvbWlzZSk7XG4gICAgICAgIHJldHVybiBzZXRBdG9tU3VzcGVuc2VQcm9taXNlKFxuICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgYXRvbSxcbiAgICAgICAgICBzdXNwZW5zZVByb21pc2UsXG4gICAgICAgICAgZGVwZW5kZW5jaWVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0QXRvbVJlYWRFcnJvcih2ZXJzaW9uLCBhdG9tLCBlcnJvck9yUHJvbWlzZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlYWRBdG9tID0gKHJlYWRpbmdBdG9tLCB2ZXJzaW9uKSA9PiB7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gcmVhZEF0b21TdGF0ZSh2ZXJzaW9uLCByZWFkaW5nQXRvbSk7XG4gICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgfTtcbiAgY29uc3QgYWRkQXRvbSA9ICh2ZXJzaW9uLCBhZGRpbmdBdG9tKSA9PiB7XG4gICAgbGV0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhZGRpbmdBdG9tKTtcbiAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgIG1vdW50ZWQgPSBtb3VudEF0b20odmVyc2lvbiwgYWRkaW5nQXRvbSk7XG4gICAgfVxuICAgIHJldHVybiBtb3VudGVkO1xuICB9O1xuICBjb25zdCBjYW5Vbm1vdW50QXRvbSA9IChhdG9tLCBtb3VudGVkKSA9PiAhbW91bnRlZC5sLnNpemUgJiYgKCFtb3VudGVkLnQuc2l6ZSB8fCBtb3VudGVkLnQuc2l6ZSA9PT0gMSAmJiBtb3VudGVkLnQuaGFzKGF0b20pKTtcbiAgY29uc3QgZGVsQXRvbSA9ICh2ZXJzaW9uLCBkZWxldGluZ0F0b20pID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoZGVsZXRpbmdBdG9tKTtcbiAgICBpZiAobW91bnRlZCAmJiBjYW5Vbm1vdW50QXRvbShkZWxldGluZ0F0b20sIG1vdW50ZWQpKSB7XG4gICAgICB1bm1vdW50QXRvbSh2ZXJzaW9uLCBkZWxldGluZ0F0b20pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaW52YWxpZGF0ZURlcGVuZGVudHMgPSAodmVyc2lvbiwgYXRvbSkgPT4ge1xuICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICBtb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBtb3VudGVkLnQuZm9yRWFjaCgoZGVwZW5kZW50KSA9PiB7XG4gICAgICBpZiAoZGVwZW5kZW50ICE9PSBhdG9tKSB7XG4gICAgICAgIHNldEF0b21JbnZhbGlkYXRlZCh2ZXJzaW9uLCBkZXBlbmRlbnQpO1xuICAgICAgICBpbnZhbGlkYXRlRGVwZW5kZW50cyh2ZXJzaW9uLCBkZXBlbmRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCB3cml0ZUF0b21TdGF0ZSA9ICh2ZXJzaW9uLCBhdG9tLCB1cGRhdGUpID0+IHtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCB3cml0ZUdldHRlciA9IChhLCBvcHRpb25zKSA9PiB7XG4gICAgICBjb25zdCBhU3RhdGUgPSByZWFkQXRvbVN0YXRlKHZlcnNpb24sIGEpO1xuICAgICAgaWYgKFwiZVwiIGluIGFTdGF0ZSkge1xuICAgICAgICB0aHJvdyBhU3RhdGUuZTtcbiAgICAgIH1cbiAgICAgIGlmIChcInBcIiBpbiBhU3RhdGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudW5zdGFibGVfcHJvbWlzZSkge1xuICAgICAgICAgIHJldHVybiBhU3RhdGUucC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBnZXRBdG9tU3RhdGUodmVyc2lvbiwgYSk7XG4gICAgICAgICAgICBpZiAocyAmJiBcInBcIiBpbiBzICYmIHMucCA9PT0gYVN0YXRlLnApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUpKS50aGVuKFxuICAgICAgICAgICAgICAgICgpID0+IHdyaXRlR2V0dGVyKGEsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVHZXR0ZXIoYSwgb3B0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgICAgIFwiUmVhZGluZyBwZW5kaW5nIGF0b20gc3RhdGUgaW4gd3JpdGUgb3BlcmF0aW9uLiBXZSB0aHJvdyBhIHByb21pc2UgZm9yIG5vdy5cIixcbiAgICAgICAgICAgIGFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGFTdGF0ZS5wO1xuICAgICAgfVxuICAgICAgaWYgKFwidlwiIGluIGFTdGF0ZSkge1xuICAgICAgICByZXR1cm4gYVN0YXRlLnY7XG4gICAgICB9XG4gICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIltCdWddIG5vIHZhbHVlIGZvdW5kIHdoaWxlIHJlYWRpbmcgYXRvbSBpbiB3cml0ZSBvcGVyYXRpb24uIFRoaXMgaXMgcHJvYmFibHkgYSBidWcuXCIsXG4gICAgICAgICAgYVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gdmFsdWUgZm91bmRcIik7XG4gICAgfTtcbiAgICBjb25zdCBzZXR0ZXIgPSAoYSwgdikgPT4ge1xuICAgICAgbGV0IHByb21pc2VPclZvaWQyO1xuICAgICAgaWYgKGEgPT09IGF0b20pIHtcbiAgICAgICAgaWYgKCFoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdG9tIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uU2V0ID0gY2FuY2VsQWxsU3VzcGVuc2VQcm9taXNlSW5DYWNoZShhKTtcbiAgICAgICAgdmVyc2lvblNldC5mb3JFYWNoKChjYW5jZWxsZWRWZXJzaW9uKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZFZlcnNpb24gIT09IHZlcnNpb24pIHtcbiAgICAgICAgICAgIHNldEF0b21Qcm9taXNlT3JWYWx1ZShjYW5jZWxsZWRWZXJzaW9uLCBhLCB2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKHZlcnNpb24sIGEpO1xuICAgICAgICBjb25zdCBuZXh0QXRvbVN0YXRlID0gc2V0QXRvbVByb21pc2VPclZhbHVlKHZlcnNpb24sIGEsIHYpO1xuICAgICAgICBpZiAocHJldkF0b21TdGF0ZSAhPT0gbmV4dEF0b21TdGF0ZSkge1xuICAgICAgICAgIGludmFsaWRhdGVEZXBlbmRlbnRzKHZlcnNpb24sIGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlT3JWb2lkMiA9IHdyaXRlQXRvbVN0YXRlKHZlcnNpb24sIGEsIHYpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgZmx1c2hQZW5kaW5nKHZlcnNpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb21pc2VPclZvaWQyO1xuICAgIH07XG4gICAgY29uc3QgcHJvbWlzZU9yVm9pZCA9IGF0b20ud3JpdGUod3JpdGVHZXR0ZXIsIHNldHRlciwgdXBkYXRlKTtcbiAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICByZXR1cm4gcHJvbWlzZU9yVm9pZDtcbiAgfTtcbiAgY29uc3Qgd3JpdGVBdG9tID0gKHdyaXRpbmdBdG9tLCB1cGRhdGUsIHZlcnNpb24pID0+IHtcbiAgICBjb25zdCBwcm9taXNlT3JWb2lkID0gd3JpdGVBdG9tU3RhdGUodmVyc2lvbiwgd3JpdGluZ0F0b20sIHVwZGF0ZSk7XG4gICAgZmx1c2hQZW5kaW5nKHZlcnNpb24pO1xuICAgIHJldHVybiBwcm9taXNlT3JWb2lkO1xuICB9O1xuICBjb25zdCBpc0FjdHVhbGx5V3JpdGFibGVBdG9tID0gKGF0b20pID0+ICEhYXRvbS53cml0ZTtcbiAgY29uc3QgbW91bnRBdG9tID0gKHZlcnNpb24sIGF0b20sIGluaXRpYWxEZXBlbmRlbnQpID0+IHtcbiAgICBjb25zdCBtb3VudGVkID0ge1xuICAgICAgdDogbmV3IFNldChpbml0aWFsRGVwZW5kZW50ICYmIFtpbml0aWFsRGVwZW5kZW50XSksXG4gICAgICBsOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICBtb3VudGVkTWFwLnNldChhdG9tLCBtb3VudGVkKTtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiAmJiBpbXBvcnQubWV0YS5lbnYuTU9ERSkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBtb3VudGVkQXRvbXMuYWRkKGF0b20pO1xuICAgIH1cbiAgICBjb25zdCBhdG9tU3RhdGUgPSByZWFkQXRvbVN0YXRlKHZvaWQgMCwgYXRvbSk7XG4gICAgYXRvbVN0YXRlLmQuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgY29uc3QgYU1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhKTtcbiAgICAgIGlmIChhTW91bnRlZCkge1xuICAgICAgICBhTW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhICE9PSBhdG9tKSB7XG4gICAgICAgICAgbW91bnRBdG9tKHZlcnNpb24sIGEsIGF0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkgJiYgYXRvbS5vbk1vdW50KSB7XG4gICAgICBjb25zdCBzZXRBdG9tID0gKHVwZGF0ZSkgPT4gd3JpdGVBdG9tKGF0b20sIHVwZGF0ZSwgdmVyc2lvbik7XG4gICAgICBjb25zdCBvblVubW91bnQgPSBhdG9tLm9uTW91bnQoc2V0QXRvbSk7XG4gICAgICB2ZXJzaW9uID0gdm9pZCAwO1xuICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICBtb3VudGVkLnUgPSBvblVubW91bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3VudGVkO1xuICB9O1xuICBjb25zdCB1bm1vdW50QXRvbSA9ICh2ZXJzaW9uLCBhdG9tKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9uVW5tb3VudCA9IChfYSA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EudTtcbiAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICBvblVubW91bnQoKTtcbiAgICB9XG4gICAgbW91bnRlZE1hcC5kZWxldGUoYXRvbSk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgbW91bnRlZEF0b21zLmRlbGV0ZShhdG9tKTtcbiAgICB9XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKHZlcnNpb24sIGF0b20pO1xuICAgIGlmIChhdG9tU3RhdGUpIHtcbiAgICAgIGlmIChcInBcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgICAgY2FuY2VsU3VzcGVuc2VQcm9taXNlKGF0b21TdGF0ZS5wKTtcbiAgICAgIH1cbiAgICAgIGF0b21TdGF0ZS5kLmZvckVhY2goKF8sIGEpID0+IHtcbiAgICAgICAgaWYgKGEgIT09IGF0b20pIHtcbiAgICAgICAgICBjb25zdCBtb3VudGVkID0gbW91bnRlZE1hcC5nZXQoYSk7XG4gICAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICAgICAgICBpZiAoY2FuVW5tb3VudEF0b20oYSwgbW91bnRlZCkpIHtcbiAgICAgICAgICAgICAgdW5tb3VudEF0b20odmVyc2lvbiwgYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFwiW0J1Z10gY291bGQgbm90IGZpbmQgYXRvbSBzdGF0ZSB0byB1bm1vdW50XCIsIGF0b20pO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbW91bnREZXBlbmRlbmNpZXMgPSAodmVyc2lvbiwgYXRvbSwgYXRvbVN0YXRlLCBwcmV2UmVhZERlcGVuZGVuY2llcykgPT4ge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKTtcbiAgICBwcmV2UmVhZERlcGVuZGVuY2llcyA9PSBudWxsID8gdm9pZCAwIDogcHJldlJlYWREZXBlbmRlbmNpZXMuZm9yRWFjaCgoXywgYSkgPT4ge1xuICAgICAgaWYgKGRlcGVuZGVuY2llcy5oYXMoYSkpIHtcbiAgICAgICAgZGVwZW5kZW5jaWVzLmRlbGV0ZShhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmRlbGV0ZShhdG9tKTtcbiAgICAgICAgaWYgKGNhblVubW91bnRBdG9tKGEsIG1vdW50ZWQpKSB7XG4gICAgICAgICAgdW5tb3VudEF0b20odmVyc2lvbiwgYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGEpO1xuICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgbW91bnRlZC50LmFkZChhdG9tKTtcbiAgICAgIH0gZWxzZSBpZiAobW91bnRlZE1hcC5oYXMoYXRvbSkpIHtcbiAgICAgICAgbW91bnRBdG9tKHZlcnNpb24sIGEsIGF0b20pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBjb25zdCBmbHVzaFBlbmRpbmcgPSAodmVyc2lvbikgPT4ge1xuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uZWRBdG9tU3RhdGVNYXAgPSBnZXRWZXJzaW9uZWRBdG9tU3RhdGVNYXAodmVyc2lvbik7XG4gICAgICB2ZXJzaW9uZWRBdG9tU3RhdGVNYXAuZm9yRWFjaCgoYXRvbVN0YXRlLCBhdG9tKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbW1pdHRlZEF0b21TdGF0ZSA9IGNvbW1pdHRlZEF0b21TdGF0ZU1hcC5nZXQoYXRvbSk7XG4gICAgICAgIGlmIChhdG9tU3RhdGUgIT09IGNvbW1pdHRlZEF0b21TdGF0ZSkge1xuICAgICAgICAgIGNvbnN0IG1vdW50ZWQgPSBtb3VudGVkTWFwLmdldChhdG9tKTtcbiAgICAgICAgICBtb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBtb3VudGVkLmwuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKHZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdoaWxlIChwZW5kaW5nTWFwLnNpemUpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmcgPSBBcnJheS5mcm9tKHBlbmRpbmdNYXApO1xuICAgICAgcGVuZGluZ01hcC5jbGVhcigpO1xuICAgICAgcGVuZGluZy5mb3JFYWNoKChbYXRvbSwgcHJldkF0b21TdGF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgYXRvbVN0YXRlID0gZ2V0QXRvbVN0YXRlKHZvaWQgMCwgYXRvbSk7XG4gICAgICAgIGlmIChhdG9tU3RhdGUgJiYgYXRvbVN0YXRlLmQgIT09IChwcmV2QXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBwcmV2QXRvbVN0YXRlLmQpKSB7XG4gICAgICAgICAgbW91bnREZXBlbmRlbmNpZXModm9pZCAwLCBhdG9tLCBhdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZBdG9tU3RhdGUgJiYgIXByZXZBdG9tU3RhdGUueSAmJiAvLyBpbnZhbGlkYXRlZFxuICAgICAgICAoYXRvbVN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBhdG9tU3RhdGUueSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW91bnRlZCA9IG1vdW50ZWRNYXAuZ2V0KGF0b20pO1xuICAgICAgICBtb3VudGVkID09IG51bGwgPyB2b2lkIDAgOiBtb3VudGVkLmwuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHN0YXRlTGlzdGVuZXJzLmZvckVhY2goKGwpID0+IGwoKSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjb21taXRWZXJzaW9uZWRBdG9tU3RhdGVNYXAgPSAodmVyc2lvbikgPT4ge1xuICAgIGNvbnN0IHZlcnNpb25lZEF0b21TdGF0ZU1hcCA9IGdldFZlcnNpb25lZEF0b21TdGF0ZU1hcCh2ZXJzaW9uKTtcbiAgICB2ZXJzaW9uZWRBdG9tU3RhdGVNYXAuZm9yRWFjaCgoYXRvbVN0YXRlLCBhdG9tKSA9PiB7XG4gICAgICBjb25zdCBwcmV2QXRvbVN0YXRlID0gY29tbWl0dGVkQXRvbVN0YXRlTWFwLmdldChhdG9tKTtcbiAgICAgIGlmICghcHJldkF0b21TdGF0ZSB8fCBhdG9tU3RhdGUuciA+IHByZXZBdG9tU3RhdGUuciB8fCBhdG9tU3RhdGUueSAhPT0gcHJldkF0b21TdGF0ZS55IHx8IGF0b21TdGF0ZS5yID09PSBwcmV2QXRvbVN0YXRlLnIgJiYgYXRvbVN0YXRlLmQgIT09IHByZXZBdG9tU3RhdGUuZCkge1xuICAgICAgICBjb21taXR0ZWRBdG9tU3RhdGVNYXAuc2V0KGF0b20sIGF0b21TdGF0ZSk7XG4gICAgICAgIGlmIChhdG9tU3RhdGUuZCAhPT0gKHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCkpIHtcbiAgICAgICAgICBtb3VudERlcGVuZGVuY2llcyh2ZXJzaW9uLCBhdG9tLCBhdG9tU3RhdGUsIHByZXZBdG9tU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZBdG9tU3RhdGUuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgY29tbWl0QXRvbSA9IChfYXRvbSwgdmVyc2lvbikgPT4ge1xuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICBjb21taXRWZXJzaW9uZWRBdG9tU3RhdGVNYXAodmVyc2lvbik7XG4gICAgfVxuICAgIGZsdXNoUGVuZGluZyh2b2lkIDApO1xuICB9O1xuICBjb25zdCBzdWJzY3JpYmVBdG9tID0gKGF0b20sIGNhbGxiYWNrLCB2ZXJzaW9uKSA9PiB7XG4gICAgY29uc3QgbW91bnRlZCA9IGFkZEF0b20odmVyc2lvbiwgYXRvbSk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gbW91bnRlZC5sO1xuICAgIGxpc3RlbmVycy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgIGRlbEF0b20odmVyc2lvbiwgYXRvbSk7XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgcmVzdG9yZUF0b21zID0gKHZhbHVlcywgdmVyc2lvbikgPT4ge1xuICAgIGZvciAoY29uc3QgW2F0b20sIHZhbHVlXSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYXRvbSkpIHtcbiAgICAgICAgc2V0QXRvbVByb21pc2VPclZhbHVlKHZlcnNpb24sIGF0b20sIHZhbHVlKTtcbiAgICAgICAgaW52YWxpZGF0ZURlcGVuZGVudHModmVyc2lvbiwgYXRvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsdXNoUGVuZGluZyh2ZXJzaW9uKTtcbiAgfTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgJiYgaW1wb3J0Lm1ldGEuZW52Lk1PREUpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBbUkVBRF9BVE9NXTogcmVhZEF0b20sXG4gICAgICBbV1JJVEVfQVRPTV06IHdyaXRlQXRvbSxcbiAgICAgIFtDT01NSVRfQVRPTV06IGNvbW1pdEF0b20sXG4gICAgICBbU1VCU0NSSUJFX0FUT01dOiBzdWJzY3JpYmVBdG9tLFxuICAgICAgW1JFU1RPUkVfQVRPTVNdOiByZXN0b3JlQXRvbXMsXG4gICAgICBbREVWX1NVQlNDUklCRV9TVEFURV06IChsKSA9PiB7XG4gICAgICAgIHN0YXRlTGlzdGVuZXJzLmFkZChsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBzdGF0ZUxpc3RlbmVycy5kZWxldGUobCk7XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgW0RFVl9HRVRfTU9VTlRFRF9BVE9NU106ICgpID0+IG1vdW50ZWRBdG9tcy52YWx1ZXMoKSxcbiAgICAgIFtERVZfR0VUX0FUT01fU1RBVEVdOiAoYSkgPT4gY29tbWl0dGVkQXRvbVN0YXRlTWFwLmdldChhKSxcbiAgICAgIFtERVZfR0VUX01PVU5URURdOiAoYSkgPT4gbW91bnRlZE1hcC5nZXQoYSlcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgW1JFQURfQVRPTV06IHJlYWRBdG9tLFxuICAgIFtXUklURV9BVE9NXTogd3JpdGVBdG9tLFxuICAgIFtDT01NSVRfQVRPTV06IGNvbW1pdEF0b20sXG4gICAgW1NVQlNDUklCRV9BVE9NXTogc3Vic2NyaWJlQXRvbSxcbiAgICBbUkVTVE9SRV9BVE9NU106IHJlc3RvcmVBdG9tc1xuICB9O1xufTtcbmNvbnN0IGNyZWF0ZVN0b3JlRm9yRXhwb3J0ID0gKGluaXRpYWxWYWx1ZXMpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShpbml0aWFsVmFsdWVzKTtcbiAgY29uc3QgZ2V0ID0gKGF0b20pID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBzdG9yZVtSRUFEX0FUT01dKGF0b20pO1xuICAgIGlmIChcImVcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgIHRocm93IGF0b21TdGF0ZS5lO1xuICAgIH1cbiAgICBpZiAoXCJwXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbVN0YXRlLnY7XG4gIH07XG4gIGNvbnN0IGFzeW5jR2V0ID0gKGF0b20pID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBzdG9yZVtSRUFEX0FUT01dKGF0b20pO1xuICAgIGlmIChcImVcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgIHJlamVjdChhdG9tU3RhdGUuZSk7XG4gICAgfSBlbHNlIGlmIChcInBcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgIHJlc29sdmUoYXRvbVN0YXRlLnAudGhlbigoKSA9PiBhc3luY0dldChhdG9tKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKGF0b21TdGF0ZS52KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzZXQgPSAoYXRvbSwgdXBkYXRlKSA9PiBzdG9yZVtXUklURV9BVE9NXShhdG9tLCB1cGRhdGUpO1xuICBjb25zdCBzdWIgPSAoYXRvbSwgY2FsbGJhY2spID0+IHN0b3JlW1NVQlNDUklCRV9BVE9NXShhdG9tLCBjYWxsYmFjayk7XG4gIHJldHVybiB7XG4gICAgZ2V0LFxuICAgIGFzeW5jR2V0LFxuICAgIHNldCxcbiAgICBzdWIsXG4gICAgU0VDUkVUX0lOVEVSTkFMX3N0b3JlOiBzdG9yZVxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlU2NvcGVDb250YWluZXIgPSAoaW5pdGlhbFZhbHVlcywgdW5zdGFibGVfY3JlYXRlU3RvcmUpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSB1bnN0YWJsZV9jcmVhdGVTdG9yZSA/IHVuc3RhYmxlX2NyZWF0ZVN0b3JlKGluaXRpYWxWYWx1ZXMpLlNFQ1JFVF9JTlRFUk5BTF9zdG9yZSA6IGNyZWF0ZVN0b3JlKGluaXRpYWxWYWx1ZXMpO1xuICByZXR1cm4geyBzOiBzdG9yZSB9O1xufTtcbmNvbnN0IFNjb3BlQ29udGV4dE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5jb25zdCBnZXRTY29wZUNvbnRleHQgPSAoc2NvcGUpID0+IHtcbiAgaWYgKCFTY29wZUNvbnRleHRNYXAuaGFzKHNjb3BlKSkge1xuICAgIFNjb3BlQ29udGV4dE1hcC5zZXQoc2NvcGUsIGNyZWF0ZUNvbnRleHQoY3JlYXRlU2NvcGVDb250YWluZXIoKSkpO1xuICB9XG4gIHJldHVybiBTY29wZUNvbnRleHRNYXAuZ2V0KHNjb3BlKTtcbn07XG5cbmNvbnN0IFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxWYWx1ZXMsXG4gIHNjb3BlLFxuICB1bnN0YWJsZV9jcmVhdGVTdG9yZSxcbiAgdW5zdGFibGVfZW5hYmxlVmVyc2lvbmVkV3JpdGVcbn0pID0+IHtcbiAgY29uc3QgW3ZlcnNpb24sIHNldFZlcnNpb25dID0gdXNlU3RhdGUoe30pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNjb3BlQ29udGFpbmVyID0gc2NvcGVDb250YWluZXJSZWYuY3VycmVudDtcbiAgICBpZiAoc2NvcGVDb250YWluZXIudykge1xuICAgICAgc2NvcGVDb250YWluZXIuc1tDT01NSVRfQVRPTV0obnVsbCwgdmVyc2lvbik7XG4gICAgICBkZWxldGUgdmVyc2lvbi5wO1xuICAgICAgc2NvcGVDb250YWluZXIudiA9IHZlcnNpb247XG4gICAgfVxuICB9LCBbdmVyc2lvbl0pO1xuICBjb25zdCBzY29wZUNvbnRhaW5lclJlZiA9IHVzZVJlZigpO1xuICBpZiAoIXNjb3BlQ29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICBjb25zdCBzY29wZUNvbnRhaW5lciA9IGNyZWF0ZVNjb3BlQ29udGFpbmVyKFxuICAgICAgaW5pdGlhbFZhbHVlcyxcbiAgICAgIHVuc3RhYmxlX2NyZWF0ZVN0b3JlXG4gICAgKTtcbiAgICBpZiAodW5zdGFibGVfZW5hYmxlVmVyc2lvbmVkV3JpdGUpIHtcbiAgICAgIGxldCByZXRyeWluZyA9IDA7XG4gICAgICBzY29wZUNvbnRhaW5lci53ID0gKHdyaXRlKSA9PiB7XG4gICAgICAgIHNldFZlcnNpb24oKHBhcmVudFZlcnNpb24pID0+IHtcbiAgICAgICAgICBjb25zdCBuZXh0VmVyc2lvbiA9IHJldHJ5aW5nID8gcGFyZW50VmVyc2lvbiA6IHsgcDogcGFyZW50VmVyc2lvbiB9O1xuICAgICAgICAgIHdyaXRlKG5leHRWZXJzaW9uKTtcbiAgICAgICAgICByZXR1cm4gbmV4dFZlcnNpb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNjb3BlQ29udGFpbmVyLnYgPSB2ZXJzaW9uO1xuICAgICAgc2NvcGVDb250YWluZXIuciA9IChmbikgPT4ge1xuICAgICAgICArK3JldHJ5aW5nO1xuICAgICAgICBmbigpO1xuICAgICAgICAtLXJldHJ5aW5nO1xuICAgICAgfTtcbiAgICB9XG4gICAgc2NvcGVDb250YWluZXJSZWYuY3VycmVudCA9IHNjb3BlQ29udGFpbmVyO1xuICB9XG4gIGNvbnN0IFNjb3BlQ29udGFpbmVyQ29udGV4dCA9IGdldFNjb3BlQ29udGV4dChzY29wZSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgIFNjb3BlQ29udGFpbmVyQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogc2NvcGVDb250YWluZXJSZWYuY3VycmVudFxuICAgIH0sXG4gICAgY2hpbGRyZW5cbiAgKTtcbn07XG5cbmZ1bmN0aW9uIGF0b20ocmVhZCwgd3JpdGUpIHtcbiAgcmV0dXJuIGF0b20kMShyZWFkLCB3cml0ZSk7XG59XG5cbmZ1bmN0aW9uIHVzZUF0b21WYWx1ZShhdG9tLCBzY29wZSkge1xuICBjb25zdCBTY29wZUNvbnRleHQgPSBnZXRTY29wZUNvbnRleHQoc2NvcGUpO1xuICBjb25zdCBzY29wZUNvbnRhaW5lciA9IHVzZUNvbnRleHQoU2NvcGVDb250ZXh0KTtcbiAgY29uc3QgeyBzOiBzdG9yZSwgdjogdmVyc2lvbkZyb21Qcm92aWRlciB9ID0gc2NvcGVDb250YWluZXI7XG4gIGNvbnN0IGdldEF0b21WYWx1ZSA9ICh2ZXJzaW9uMikgPT4ge1xuICAgIGNvbnN0IGF0b21TdGF0ZSA9IHN0b3JlW1JFQURfQVRPTV0oYXRvbSwgdmVyc2lvbjIpO1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWF0b21TdGF0ZS55KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaG91bGQgbm90IGJlIGludmFsaWRhdGVkXCIpO1xuICAgIH1cbiAgICBpZiAoXCJlXCIgaW4gYXRvbVN0YXRlKSB7XG4gICAgICB0aHJvdyBhdG9tU3RhdGUuZTtcbiAgICB9XG4gICAgaWYgKFwicFwiIGluIGF0b21TdGF0ZSkge1xuICAgICAgdGhyb3cgYXRvbVN0YXRlLnA7XG4gICAgfVxuICAgIGlmIChcInZcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICAgIHJldHVybiBhdG9tU3RhdGUudjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYXRvbSB2YWx1ZVwiKTtcbiAgfTtcbiAgY29uc3QgW1t2ZXJzaW9uLCB2YWx1ZUZyb21SZWR1Y2VyLCBhdG9tRnJvbVJlZHVjZXJdLCByZXJlbmRlcklmQ2hhbmdlZF0gPSB1c2VSZWR1Y2VyKFxuICAgIChwcmV2LCBuZXh0VmVyc2lvbikgPT4ge1xuICAgICAgY29uc3QgbmV4dFZhbHVlID0gZ2V0QXRvbVZhbHVlKG5leHRWZXJzaW9uKTtcbiAgICAgIGlmIChPYmplY3QuaXMocHJldlsxXSwgbmV4dFZhbHVlKSAmJiBwcmV2WzJdID09PSBhdG9tKSB7XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuZXh0VmVyc2lvbiwgbmV4dFZhbHVlLCBhdG9tXTtcbiAgICB9LFxuICAgIHZlcnNpb25Gcm9tUHJvdmlkZXIsXG4gICAgKGluaXRpYWxWZXJzaW9uKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRBdG9tVmFsdWUoaW5pdGlhbFZlcnNpb24pO1xuICAgICAgcmV0dXJuIFtpbml0aWFsVmVyc2lvbiwgaW5pdGlhbFZhbHVlLCBhdG9tXTtcbiAgICB9XG4gICk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRnJvbVJlZHVjZXI7XG4gIGlmIChhdG9tRnJvbVJlZHVjZXIgIT09IGF0b20pIHtcbiAgICByZXJlbmRlcklmQ2hhbmdlZCh2ZXJzaW9uKTtcbiAgICB2YWx1ZSA9IGdldEF0b21WYWx1ZSh2ZXJzaW9uKTtcbiAgfVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgdjogdmVyc2lvbkZyb21Qcm92aWRlcjIgfSA9IHNjb3BlQ29udGFpbmVyO1xuICAgIGlmICh2ZXJzaW9uRnJvbVByb3ZpZGVyMikge1xuICAgICAgc3RvcmVbQ09NTUlUX0FUT01dKGF0b20sIHZlcnNpb25Gcm9tUHJvdmlkZXIyKTtcbiAgICB9XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZVtTVUJTQ1JJQkVfQVRPTV0oXG4gICAgICBhdG9tLFxuICAgICAgcmVyZW5kZXJJZkNoYW5nZWQsXG4gICAgICB2ZXJzaW9uRnJvbVByb3ZpZGVyMlxuICAgICk7XG4gICAgcmVyZW5kZXJJZkNoYW5nZWQodmVyc2lvbkZyb21Qcm92aWRlcjIpO1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW3N0b3JlLCBhdG9tLCBzY29wZUNvbnRhaW5lcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHN0b3JlW0NPTU1JVF9BVE9NXShhdG9tLCB2ZXJzaW9uKTtcbiAgfSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVNldEF0b20oYXRvbSwgc2NvcGUpIHtcbiAgY29uc3QgU2NvcGVDb250ZXh0ID0gZ2V0U2NvcGVDb250ZXh0KHNjb3BlKTtcbiAgY29uc3QgeyBzOiBzdG9yZSwgdzogdmVyc2lvbmVkV3JpdGUgfSA9IHVzZUNvbnRleHQoU2NvcGVDb250ZXh0KTtcbiAgY29uc3Qgc2V0QXRvbSA9IHVzZUNhbGxiYWNrKFxuICAgICh1cGRhdGUpID0+IHtcbiAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcIndyaXRlXCIgaW4gYXRvbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHdyaXRhYmxlIGF0b21cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB3cml0ZSA9ICh2ZXJzaW9uKSA9PiBzdG9yZVtXUklURV9BVE9NXShhdG9tLCB1cGRhdGUsIHZlcnNpb24pO1xuICAgICAgcmV0dXJuIHZlcnNpb25lZFdyaXRlID8gdmVyc2lvbmVkV3JpdGUod3JpdGUpIDogd3JpdGUoKTtcbiAgICB9LFxuICAgIFtzdG9yZSwgdmVyc2lvbmVkV3JpdGUsIGF0b21dXG4gICk7XG4gIHJldHVybiBzZXRBdG9tO1xufVxuXG5mdW5jdGlvbiB1c2VBdG9tKGF0b20sIHNjb3BlKSB7XG4gIGlmIChcInNjb3BlXCIgaW4gYXRvbSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwiYXRvbS5zY29wZSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgZG8gdXNlQXRvbShhdG9tLCBzY29wZSkgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgc2NvcGUgPSBhdG9tLnNjb3BlO1xuICB9XG4gIHJldHVybiBbXG4gICAgdXNlQXRvbVZhbHVlKGF0b20sIHNjb3BlKSxcbiAgICAvLyBXZSBkbyB3cm9uZyB0eXBlIGFzc2VydGlvbiBoZXJlLCB3aGljaCByZXN1bHRzIGluIHRocm93aW5nIGFuIGVycm9yLlxuICAgIHVzZVNldEF0b20oYXRvbSwgc2NvcGUpXG4gIF07XG59XG5cbmV4cG9ydCB7IFByb3ZpZGVyLCBnZXRTY29wZUNvbnRleHQgYXMgU0VDUkVUX0lOVEVSTkFMX2dldFNjb3BlQ29udGV4dCwgcmVnaXN0ZXJQcm9taXNlQWJvcnQgYXMgU0VDUkVUX0lOVEVSTkFMX3JlZ2lzdGVyUHJvbWlzZUFib3J0LCBhdG9tLCBjcmVhdGVTdG9yZUZvckV4cG9ydCBhcyB1bnN0YWJsZV9jcmVhdGVTdG9yZSwgdXNlQXRvbSwgdXNlQXRvbVZhbHVlLCB1c2VTZXRBdG9tIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3582\n')}}]);